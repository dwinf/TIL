# 분산 시스템 Fundamental
### 컴퓨터의 진화
30년대 최초의 등장 - 튜링머신
사람이 수기로 할 일을 대신해주는 정도. 단, 컴퓨터 머신에 수동으로 작업 등록 후 실행

40년대 장비가 작아지고 폰노이만 아키텍처 + 애니악 등장 -> 현대 컴퓨터의 구조
input -> cpu/memory -> output 구조
이때부터 프로그래밍 언어 등장

80년대 프로그램을 작성하고 구동하는 방식
ibm x86아키텍처, microprocessor 개발
위 환경하에서 어셈블리어, 고급언어 구현 및 발전


### Remote Procedure Call
프로그램의 **원격** 호출 -> 물리적 제약에서 벗어남
컴퓨터에게 더 간단하게 더 많은 일을 시킬 수 있게 됨
80년대 rpc 구현으로 Server-Client model 구현 가능


### Database
컴퓨팅 성능 향상으로 더 많은 데이터 처리 가능 + rpc로 물리적 제약 X
=> 대용량 데이터 전문 처리장치 개발
SQL 정립 + 상용 DB 등장
데이터 처리량은 Scale-up을 통해 해결


### 3-Tier Architecture
![그림](https://docs.aws.amazon.com/images/whitepapers/latest/serverless-multi-tier-architectures-api-gateway-lambda/images/image2.png)



### Web-Was-DB
서비스의 대부분의 요청을 보니 90% 이상이 정적인 데이터
정적인 데이터에 대한 요청은 응답을 저장해두고 빠르게 처리하고, 실제 processing이 필요한 데이터만 Application Server, Database까지 전달해서 처리하자는 것
일련의 3-Tier Architecture



### 한계점
기존 방식에서의 문제 해결은 scale-up(hw의 성능 향상)을 통해 해결
하지만 이 방식으로는 기하급수적으로 늘어나는 트래픽이나 데이터를 감당하지 못함
=> 소프트웨어를 통해 문제를 해결하고자 함 => 분산시스템


### 분산 시스템이 필요한 이유
원격 처리 처리 장치의 수를 늘리는 scale out 전략
scale out을 하려면 상태를 공유하지 않아야 한다

Application Server (remote processor)는 LoadBalancer 를 전처리 장치로 두면 상태 없이 scale-out 확장하는 것이 가능했다. 하지만 온라인 서비스의 핵심이라고 할 수 있는 Database 는 대량의 데이터를 공유해야하기 때문에 쉽게 scale-out을 할 수 없었다. (Sharding 기능이 생기기 전)

따라서 데이터베이스를 중심으로 여러대의 서버로 scale-out 이 가능하면서도 상태와 데이터의 공유가 가능하고 user(client)가 사용하는 기능에는 변화가 없는 소프트웨어가 필요해졌다. (물론 데이터베이스가 아닌 시스템들도 분산시스템을 필요로 했다.)

---
---


# 2. 분산 시스템의 특징
### 기본 특징
Concurrency(동시성)
- 자원은 공유, 리소스내에서 동시에 여러가지 작업을 수행
No Global Clock(비동기)
- 각 부분이 비동기식으로 동작
- 어떤 한 부분의 상태 때문에 다른 곳에 Lock, Bottleneck 이 걸리면 안된다
Independent Failure
- 시스템의 한 부분의 실패가 전체 시스템에 영향(장애)을 주면 안된다
- 최소한 이론적으로나마 가능해야...


### 고려요소
Heterogeneity
- 서로 다른 시스템에 설치 및 그 사이에 정보와 자원을 공유하며 동작
- OS, HW 관계없이 일관된 개발을 하기 위한 언어를 선택한다
Openess
- 서로 다른 요소 사이의 연결과 확장, 상호 운용이 가능
- 주요 인터페이스를 노출하고, 일관된 커뮤니케이션(프로토콜) 방식을 사용해야
Security
- 권한 제어 , 접근제어
- Confidentially: 권한이 없다면 공개 불가
- Integrity: 허가되지 않은 방법으로 변경할 수 없다.
- Availability: 권한이 있다면 접근이 가능해야한다.
Scalability
- 확장 가능. 주로 scale-out
- scale-up이 안되서 하는거니까..!
failure Handling
- 장애/실패에 대한 대응을 (자동화된 방식으로) 할 수 있어야 함
- Detecting Failure, Masking F, Tolerating F, Recovery F, Redundancy
Concurrency
- 여러 클라이언트가 하나의 공유 자원에 접근하는 등의 동시성에 대한 문제를 해결
Transparency
- 사용자로부터 내부에 있는 정보를 보이지 않게 하고
- 다양한 투명성을 달성해야한다
    - Access transparency: enables local and remote resources to be accessed using identical operations
    - Location transparency: enables resources to be accessed without knowledge of their physical or network location (for example, which building or IP address)
    - Concurrency transparency: enables several processes to operate concurrently using shared resources without interference between them
    - Replication transparency: enables multiple instances of resources to be used to increase reliability and performance without knowledge of the replicas by users or application programmers
    - Failure transparency: enables the concealment of faults, allowing users and application programs to complete their tasks despite the failure of hardware or software components
    - Mobility transparency: allows the movement of resources and clients within a system without affecting the operation of users or programs
    - Performance transparency: allows the system to be reconfigured to improve performance as loads vary
    - Scaling transparency: allows the system and applications to expand in scale without change to the system structure or the application algorithms


## BASE Principle
- **Basically Available(BA)** – 전체가 이용불가능한 상태는 없다. 부분적인 장애는 가능.
    - 데이터 replica 를 만든다.
    - 한 종류의 data 를 여러 노드에 분산한다.
- **Soft State(S)** – 응답하는 데이터(또는 집합의) 상태는 inconsistency 할 수 있다. 이것에 대한 책임은 사용자에게 있다.
- **Eventually Consistent(E)** – 입력된 데이터는 약간의 지연이 있을수는 있지만, 결국에는 언젠가는 저장, 조회가 될 것이다.