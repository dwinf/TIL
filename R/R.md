# R

> 2/22
>
> 마리아DB, 몽고DB를 이용한 데이터 처리
>
> 통계학자들이 만든 통계(데이터셋)처리 전문 언어

- 데이터 수집과 저장
- EDA(Exploratory Data Analysis)를 통한 시각화와 전처리
- 데이터 분석
- 분석 결과 시각화 표현

---

## 1. R &  RStudio 설치

> R 개발환경설치.docx 파일 참고

```R
100:200
200:100
v <- 100:200
v
print(v)
v[1]	# 1
# [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117
# ...
# [91] 190 191 192 193 194 195 196 197 198 199 200
v[1]	# 1

v+1000
#  [1] 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113
# ...
# [99] 1198 1199 1200

plot(v*10)
# 그래프를 그려줌(y축=v, x축=인덱스)
letters	#영소문자
LETTERS	#영대문자
```

- `<-` : R에서의 대입연산자(`=`도 사용 가능)
- [91] : 행의 첫번째 원소의 인덱스
  - R의 인덱스는 1부터 시작
- letters : 영문자를 출력(변수에 대입 가능)
  - s = letters



## 2. R 기본

### R구문 학습 내용

- R로 다룰 수 있는 데이터 종료 : 자료형(data type)
- R로 다룰 수 있는 데이터셋 종류 : 벡터, 행렬, 배열, 데이터프레임, 리스트
- R에서 사용 가능한 연산자
- 제어문 : for, while, repeat, if, else if, else, break, next(continue 기능)
- 함수 정의와 활용
- 파일에 있는 데이터 읽기 : csv, xml, json, xlsx, txt

![image-20210222113042796](C:\Users\dwinf\AppData\Roaming\Typora\typora-user-images\image-20210222113042796.png)

### 1. R의 자료형

- 문자형(character) : 문자, 문자열 
- 수치형(numeric) : 정수(integer), 실수(double) 
- 복소수형(complex) : 실수+허수 
- 논리형(logical) : 참값과 거짓값



### 2. R의 리터럴

- 문자형(character)리터럴 :"가나다", '가나다', "", '', '123', "abc"  (인용부호로 묶이면 문자형)
- 수치형(numeric)리터럴 : 100, 3.14, 0 
- 논리형(logical)리터럴 : TRUE(T), FALSE(F) 
- NULL(데이터 셋이 비어있음을 의미), 
- NA(데이터 셋의 내부에 존재하지 않는 값(결측치)를 의미) : Not Available
-  NaN(not a number: 숫자가 아님), 
- Inf(무한대값)

#### 타입체크

- `is.character(x)` - 문자형 
- `is.logical(x)` - 논리형 
- `is.numeric(x)` - 수치형
  - `is.double(x)` - 실수형 
  - `is.integer(x)` - 정수형
- `is.null(x)` 
- `is.na(x)` 
- `is.nan(x)`
- `is.finite(x)` 
- `is.infinite(x)`

#### 자동형변환 룰

문자형 > 복소수형 > 수치형 > 논리형

#### 강제형변환 함수

- `as.character(x)` / `as.complex(x)` /  `as.numeric(x)`

- `as.double(x)` / `as.integer(x)` / `as.logical(x)`

#### 자료형/구조 확인

- `class(x)`, `str(x)`, `mode(x)`, `typeof(x)`



### 3. R의 데이터셋

 벡터(팩터), 행렬, 배열, 데이터프레임(정형데이터에 주로 이용), 리스트

![image-20210222131133618](C:\Users\dwinf\AppData\Roaming\Typora\typora-user-images\image-20210222131133618.png)

- 벡터(1차원), 행렬(2차원), 배열(1차원 이상) - 같은 타입의 데이터만 저장 가능
- 스칼라는 벡터로 인식되어 사실상 존재하지 않는다.
- 팩터 : 특별한 형태의 벡터



#### 데이터 프레임

- 열 단위로 서로 다른 타입의 데이터 저장 가능

#### 리스트

- 데이터 타입, 종류에 구애받지 않는다.

#### 벡터(vector)

- 가장 기초적인 데이터셋으로 1차원으로 사용
- 하나의 데이터값도 벡터
- **동일 타입의 데이터만으로 구성**
  - 문자형 저장 후 논리형을 저장하면 자동으로 문자형으로 형변환

```R
v2 <- c(100, 200, TRUE, FALSE); print(v2)	#100 200   1   0
v3 <- c('100', 200, T, F); print(v3)	#"100"   "200"   "TRUE"  "FALSE"
```

- 벡터 생성
  - `c()`, `seq()`, `rep()`, `:` 연산자

```R
v1 <- c(4, 1, 8, 6, 10)	# 4 1 8 6 10	c()함수에는 아규먼트를 원하는 만큼 전달 가능
v1[0]	# numeric(0)
v1[6]	# NA
v2 <- seq(1, 9, 2) 	# 1 3 5 7 9 == sep(1,10,by=2)
v3 <- rep(1, 5)		# 1 1 1 1 1
v4 <- rep(1:3, 3) 	# 1 2 3 1 2 3 1 2 3 == rep(1:3, times=3)	
v5 <- rep(1:4, each=2)	# 1 1 2 2 3 3 4 4
v6 <- 1:10	# 1 2 3 4 5 6 7 8 9 10
v7 <- 10:1	# 10 9 8 7 6 5 4 3 2 1
```

- 내장된 상수 벡터들

```R
LETTERS	# A B C D E ... X Y Z
letters	# a b c d e ... x y z
month.name	# "January"   "February"  "March" ... "December"
month.abb	# "Jan" "Feb" "Mar" ... "Dec"
pi	# 3.141593
```

- 주요 함수
  - length(길이 리턴), names(엘리먼트에 이름 부여), sort(오름차순 정렬), order() ...

- 인덱싱이 가능

```R
LETTERS[1]; LETTERS[c(3,4,5)]
LETTERS[3:5]; LETTERS[5:3]
LETTERS[-1]; LETTERS[c(-2,-4)]	# 음의 값 인덱스 제외
v3 <- v2[-5]	# 5번째 인덱스를 제외시킴
x[3];x[3] <- 20	# 3번 인덱스 출력, 20 대입
x[c(F,T,F,T,F)] # x[c(T,F)] --> x[c(T,F,T,F,T)]
# 논리형으로도 접근 가능. TRUE일 경우 출력 2,4번 인덱스의 값 출력
x[x > 5]	# 5보다 크면 TRUE
x[x > 5 & x < 15]	# 5보다 크고 15보다 작은 값 출력
# 논리연산을 사용하면 해당하는 값을 출력
```



#### 행렬(Matrix)

- 2차원 벡터
- **동일 타입의 데이터만 저장 가능**
- 인덱싱 : **[행의인덱싱, 열의인덱싱]**,[행의인덱싱, ], [, 열의인덱싱], **drop 속성-행렬구조 유지여부**(기본 T)
- 행렬 생성방법 : **matrix(data=벡터, nrow=행의갯수, ncol=열의갯수, [byrow=TRUE])**
  - 행의 개수 혹은 열의 개수중 하나는 주지 않아도 된다. -> 원소값의 개수에 따라 행렬 생성
  - 기본적으로 열부터 채워감
    - `byrow=TRUE`를 주면 행부터 채움
  - rbind(벡터들..), cbind(벡터들..)

```R
x1 <-matrix(1:8, nrow = 2)	# ncol 매개변수 생략
x1<-x1*3	# 모든 원소값 x3
x2 <-matrix(1:8, nrow =3)	# 행렬의 비는 부분은 1, 2, 3... 순으로 채움

(chars <- letters[1:10]) # 바로 출력하여 확인할 경우 유용
mat1 <-matrix(chars)	# 10행 1열 행렬 생성(열의 개수 지정x)

matrix(chars, nrow=5)	# 5행2열 행렬(1열부터 채움)
matrix(chars, nrow=5, byrow=T)	# 5행2열 행렬(1행부터 채움)

m <- matrix(chars, nrow=3)
m[1,1]
m[3,4]
m[3,4] <- 'w'	# 인덱스를 통해 요소를 바꿈
colnames(m)
rownames(m)
#행과 열에 이름 부여
colnames(m) <- c('c1', 'c2', 'c3', 'c4')
rownames(m) <- c('r1', 'r2', 'r3')

vec1 <- c(1,2,3)
vec2 <- c(4,5,6)
vec3 <- c(7,8,9)
mat1 <- rbind(vec1,vec2,vec3); mat1	# 벡터가 행으로 들어감
mat2 <- cbind(vec1,vec2,vec3); mat2	# 벡터가 열로 들어감
```

- 행렬에 관한 다양한 함수들
  - dim(m)-행렬이 몇차원인지 체크, nrow(행렬), ncol(행렬) colnames(m), rownames(m), rowSums(m), colSums(m), rowMeans(m), colMeans(m), sum(m), mean(m), **apply(m, 1 또는 2, 함수)**



#### 배열(Array)

- 3차원 벡터
- 동일 타입의 데이터만 저장 가능
- 인덱싱 : **[행의 인덱싱, 열의 인덱싱, 층(면)의 인덱싱]**

```R
a1 <- array(1:30, dim=c(2,3,5)) # dim 매개변수 필수
a1 # 2행 3열 5면의 3차원

a1[1,3,4]
a1[,,3]
a1[,2,]
a1[1,,]
a1*100
```



#### 팩터(factor)

- 가능한 범주값(level) 만으로 구성되는 벡터
  - 범주형 데이터셋(벡터, 행렬, 배열 등은 질적 데이터)
- 팩터의 생성
  -  factor(벡터), factor(벡터[, levels=레벨벡터]), factor(벡터[, levels=레벨벡터], ordered=TRUE)

- 팩터의 레벨 정보 추출 : levels(팩터변수)



#### 데이터프레임(data.frame)

- 2차원 구조 
- 열 단위로 서로 다른 타입의 데이터들로 구성 가능 
- **모든 열의 데이터 개수(행의 개수)는 동일해야 한다.** 
- 데이터프레임 생성 방법 
  - **data.frame**(백터들..)
  - data.frame(열이름=벡터,…) 
  - data.frame(벡터들…) [**,stringsAsFactors=FALSE**])  # 4.0 이전에는 T가 기본 4.0 부터는 F 가 기본 
  - as.data.frame(벡터 또는 행렬 등)
- 데이터프레임 변환 : **rbind(df, 백터), cbind(df, 벡터)**
  - 주로 cbind를 사용
- 데이터프레임의 구조 확인 :**str(df)**, dim(df) 
- 인덱싱 : **[행의인덱싱, 열의인덱싱],[열의인덱싱]**, **df$컬럼이름**, [[열인덱싱]]
  - 일반적으로 열의 인덱싱을 우선으로 처리하므로 컬럼이름 혹은 숫자만 작성할 경우 열의 인덱싱으로 간주
  - 인덱싱에 조건식을 줄 수 있다.
- 원하는 행과 열 추출 : subset(df, select=컬럼명들, subset=(조건))



---

데이터셋의 집합을 다루는 것은 벡터, 행렬, 배열, 데이터프레임을 주로 사용한다.



#### 리스트(List)

- 데이터 셋들을 다루는데 많이 사용
- **저장 가능한 데이터의 타입, 데이터 셋의 종류에 제한이 없다.** 
  - 벡터, 행렬, 배열, 데이터프레임, 리스트(중첩 가능), 함수 등
- 리스트를 만들어서 사용하는 경우가 많지 않다.
  - 리턴값이 리스트인 함수가 많음
  - 리스트의 활용이 중요
- 데이터 프레임 등의 서로 다른 구조의 데이터를 하나로 묶을 수 있는 자료구조이다. 
- R에서는 **통계 분석 결과가 리스트 구조로 제시되는 경우가 많으며** 서로 다른 구조의 다수의 데이터 객체를 개별로 따로 따로 관리하는 것보다는, 이것들을 리스트라는 한 바구니에 가지 런히 정리해서 모아놓으면 관리하기 편하다. 
- list() 함수로 리스트를 생성하고, `[`, `[[`, `$` 을 통해 부분집합을 뽑아낸다.
  - `[` : 리스트가 포함된 하위 **리스트**를 뽑아낸다.
  - `[[`, `$` : 하위 리스트가 포함한 원소를 추출하고 계층구조 수준을 한 단계 제거한다.
    - $는 이름이 부여되어 있을 경우 사용 가능

```R
a <- list(
	a=1:3,
    b="a string",
    c=pi,
    d=list(-1,-5)
)
```

- 리스트에서는 변수마다 가진 데이터 개수가 달라도 된다.
  - 데이터프레임과 차이점

![리스트 구조 예시](C:\Users\dwinf\AppData\Roaming\Typora\typora-user-images\image-20210224114321766.png)

- `unlist()` : 리스트를 해제하여 벡터로 변환



### R의 연산자

| 연산자     | 기능               | 연산자                         | 기능                        |
| ---------- | ------------------ | ------------------------------ | --------------------------- |
| {}         | 블록 정의          | %*%    %/%    %%               | 행렬의 곱, 몫 나머지 연산자 |
| ()         | 괄호 기능          | *     /                        | 곱셈, 나눗셈 연산자         |
| $          | 성분 추출          | +    -                         | 덧셈, 뺄셈 연산자           |
| []    [[]] | 첨자 표현          | <    >    <=    >=    ==    != | 비교 연산자                 |
| ^    **    | 제곱 연산자        | !                              | 부정 연산자                 |
| -          | 음의 부호 연산자   | &    &&    \|    \|\|          | 논리 연산자                 |
| :          | 연속된 데이터 정의 | <-    =    ->                  | 할당연산자                  |
|            |                    | <<-                            | 전역 할당 연산자            |



### R의 데이터 입출력

[콘솔 화면에 데이터를 출력하는 함수] -print(): 데이터셋 또는 데이터를 출력, cat(): aptlwlfmf cnffurgkf Eo

- print(x, …)
  - print(출력데이터 [, 옵션들])

- cat() 
  - cat(…, 옵션들…) : 여러 개 들어갈 수 있음



### 제어문

> 조건문, 반복문

주어진 명령을 수행하는데 있어서 조건에 따라서 수행여부를 정하고자 하는 경우(조건문 if)

필요한 만큼 반복 수행하려는 경우(반복문 for, while, repeat)

제어문을 적용하여 수행하려는 명령이 여러 개이면 블록({ }) 로 구성한다.
명령이 1줄이면 블록을 구성하지 않아도 된다.

#### 1. 조건문

##### if문

```R
if(조건1)
  	수행명령문장1
else if(조건2){
    수행명령문장2
    수행명령문장3
}
else
  	수행명령문장n
```

**ifelse 함수**

- ifelse(조건, 조건이 참일 때 명령문1, 조건이 거짓일 때 명령문2)

```R
df4$grade <- ifelse(df4$score >= 150, 'A', 
                    ifelse(df4$score >=100, 'B', 
                           ifelse(df4$score >= 70, 'C', 'D')))
```



##### switch문

- switch(**EXPR=수치데이터**, 식1, 식2, 식3, …)

- switch(**EXPR=문자열데이터**, 비교값1=식1, 비교값2=식2, 비교값3=, 비교값4=식3, …, 식4)
  - 비교값3, 비교값4일 경우에는 식3 적용
  - 뒤의 비교값과 같은 식을 사용할 경우 식 생략

 

#### 2. 반복문

##### (1) for문

for (변수 in 데이터셋) 

​	수행명령문장

##### (2) while문

while (조건) 

 	수행명령문장

##### (3) repeat문 (while (TRUE)와 동일 == 무한 루프)

- 적어도 한 번 이상 명령문을 실행, 무한 루프에서 벗어나기 위해 분기문을 반드시 포함.



#### 3. 분기문

##### break

- 해당 루프(반복문)를 종료.
- 가장 가까운 반복문을 탈출한다.

##### next (=continue)

- 현재 반복을 종료하고 실행 위치를 다음 반복문으로 이동.

**(반복문내에서는 화면에 결과 출력시 출력함수(print() 또는 cat())를 사용해야 한다.)**



### 함수

> R  프로그램의 주요 구성 요소로서 특정 작업을 독립적으로 수행하는 프로그램 코드 집합.
>
> 함수를 사용하여 반복적인 연산을 효과적으로 할 수 있음

#### 1. 함수의 처리 과정

- 시작(입력) :매개변수를 통해 아규먼트값을 받아옴

- 실행(연산) : 연산, 변환 등..

- 종료(출력) :수행결과를 데이터셋으로 반환, 출력 등..



#### 2. 함수 정의

- ```R
  함수명 <- function([매개변수]){
  	함수의 수행 코드
  	[return(리턴값)]
  }
  ```

- 호출시 함수가 정의하고 있는 **매개변수(기본값이 없는)** 사양에 맞춰서 아규먼트를 전달해야 한다.
- 리턴값이 없는 함수는 NULL 이 리턴된다.
- 리턴값은 **return()** 이라는 함수를 호출하여 처리
  - return() 문이 생략된 경우에는 마지막으로 출력된 데이터값이 자동으로 리턴된다. 
  - 가급적 리턴함수를 사용하여 명확히 구현하는 것이 필요하다.
- 아규먼트의 타입을 제한하려는 경우에는 is.xxxx() 함수를 활용한다.
- 기본값을 갖는 매개변수 선언하여 선택적으로 전달되는 아규먼트를 처리할 수 있다. 
- 아규먼트의 개수와 타입을 가변적으로 처리 가능하며 리턴값의 경우에도 선택적으로 처리 가능하다.
- 함수 안에서 만들어진 변수는 지역변수이며, 지역변수는 함수내에서만 사용 가능하다.
- 함수 안에서 만들어지지 않은 변수를 사용할 때는 전역 변수를 사용하는 결과가 된다.
  
  - 전역변수에도 존재하지 않으면 오류 발생
- 함수내에서 전역변수에 값을 저장하려는 경우 대입연산자로 <<- 을 사용한다. 



#### 3. 함수 호출

```R
변수명<- 함수명()
변수명<- 함수명(아규먼트)
함수명()
함수명(아규먼트)
```



#### 4. 함수 예시

```R
f1 <- function() print("TEST") # 수행문장이 1문장이면 중괄호는 생략할 수 있다.
f1()	# 매개변수 주면 에러(<->자바스크립트)

f2 <- function(num){print("TEST");print(num)}
f2(100)	# 매개변수 사양을 맞춰서 호출

f3<- function (p="R") print(p)	# 기본값이 있는 매개변수         
f3(); f3(p="PYTHON"); f3("java")	# 기본값이 있으면 아규먼트르 주지 않아도 된다.

f4<- function (p1="ㅋㅋㅋ",p2) for(i in 1:p2) print(p1)
f4(p1="abc", p2=3); f4("abc", 3); f4(p2=5)
f4(5)	# 에러발생. p1으로 대입된다. 기본값이 뒤에 있다면 가능
```

- 함수 내부의 변수는 지역변수이기 때문에 함수 밖에서는 호출 불가
  - 전역변수 이용시 가능(`<<-` 연산자로 전역변수 사용)

**가변인자 활용**

```R
f5<- function(...) { print("TEST"); data <- c(...); print(length(data))}
f5(10, 20, 30); f5(“abc”, T, 10, 20)

f6<- function(...) {
    print("수행시작")
data<- c(...)
for(item in data) {
	print(item)
    }
return(length(data))
}
f6()
f6(10)
f6(10,20)
f6(10,20,30)
f6(10,’abc’, T, F)

f7<- function(...) {
data<- c(...)	# 벡터로 만듦
sum<- 0;
for(item in data) {
	if(is.numeric(item))
	   sum<- sum + item
	else
	   print(item)
}
return(sum)
}
f7(10,20,30)
f7(10,20,"test", 30,40) # 벡터는 동일한 데이터 타입만 저장. 문자열로 형변환됨

f8<- function(...) {
data<- list(...)
sum<- 0;
for(item in data) {
	if(is.numeric(item))
	   sum<- sum + item
	else
	   print(item)
    }
return(sum)
}
f8(10,20,30); f8(10,20,"test", 30,40)
```

- 함수의 매개변수로 `...` 를 사용해 가변인수를 매개변수로 가용
  - 아규먼트의 타입이 상관 없으면 벡터로 저장 후 사용
  - 데이터 타입을 유지해야 한다면 리스트로 저장 후 사용



### 파일입출력

#### scan()

```R
nums <- scan("data/sample_num.txt") # 숫자 읽는 것에 특화. 문자는 에러
word_ansi <- scan("data/sample_ansi.txt",what="") # 문자열, 실수 이용 시
words_utf8 <- scan("data/sample_utf8.txt", what="",encoding="UTF-8")
words_utf8_new <- scan("data/sample_utf8.txt", what="")
```

- `scan()` 함수는 숫자를 읽는 것에 특화
- 문자, 실수를 읽기 위해서는 `what=''` 사용
- UTF-8 형식의 파일은 인코딩 타입 지정

#### readLines()

```R
lines_ansi <- readLines("data/sample_ansi.txt")
lines_utf8 <- readLines("data/sample_utf8.txt",encoding="UTF-8")
```

- `readlines()`는 파일을 문장 단위로 읽어옴

#### read.csv ()

- `,` 로 구분되는 파일을 읽을 때
- 데이터프레임
- 첫 행은 무조건 컬럼명으로 인식
- 확인해보니 공백으로 구분되는 파일도 읽어오긴 함
  - 단, 열 구분은 안됨

```R
df3 <- read.csv('data/emp.csv')
```

#### read.table()

- `공백 또는 탭`으로 구분되는 파일을 읽을 때
- 데이터프레임
- 파일을 읽을 때 컬럼명을 자동으로 부여(v1, v2...)
- 첫 행부터 데이터로 저장
- csv파일도 읽긴 하지만 열 구분은 안됨(형식파괴)

```R
df2 <- read.table("data/product_click.log", stringsAsFactors = T) 
# read.csv와 유사, 문자열은 팩터로 인식하도록
```

