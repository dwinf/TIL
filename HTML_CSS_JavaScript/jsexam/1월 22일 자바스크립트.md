# 1월 22일 자바스크립트

```javascript
<script src="util.js"></script>
```

- 스크립트 태그를 몇개를 사용해도 상관없음
- src 속성을 이용해 가져오고자 하는 자바스크립트 파일을 가져옴(CSS와 유사)
  - 같은 디렉토리일 때는 파일 이름만 줘도 된다.
- 사용하고자 하는 스크립트보다 먼저 선언되어야 사용할 수 있다.

```javascript
//util.js 파일
function write(content, tag) {
	document.write("<"+tag+">"+content+"</"+tag+">");	
}
function hr() {
	document.write("<hr>");
}
function writeColor(content, tag, color) {
	document.write("<"+tag+" style='color:"+color+"'>"+
			  content+"</"+tag+">");	
}
function writeNewLine(content) {
	document.write(content+"<br>");	
}
```

```javascript
<script src="util.js"></script>
var num1 = 100;
let num2 = 200;
const num3 = 300;
writeColor("num1 : " + num1, "h1", "red");
writeColor("num2 : " + num2, "h1", "green");
writeColor("num3 : " + num3, "h1", "blue");
num1 = '가';
num2 = '나';
//num3 = '다';
writeColor("num1 : " + num1, "h2", "red");
writeColor("num2 : " + num2, "h2", "green");
writeColor("num3 : " + num3, "h2", "blue");
var num1 = 3.5;
//let num2 = 4.7;
//const num3 = 5.3;
writeColor("num1 : " + num1, "h3", "red");
writeColor("num2 : " + num2, "h3", "green");
writeColor("num3 : " + num3, "h3", "blue");
```

- `var` : 변수의 재할당, 재선언 가능
- `let` : 변수의 재할당 가능, 재선언 불가
- `const` : 변수를 상수로 만듦. 재할당, 재선언 불가

##### 자바스크립트의 변수 범위

```javascript
<script src="util.js"></script> 
var g_v = 100;
function scopeTest() {
	var l_v = 1000;
	writeNewLine("scopeTest() l_v : " + l_v);
	writeNewLine("scopeTest() g_v : " + g_v );
}
scopeTest();
try {
	writeNewLine("l_v : " + l_v  );
} catch(e) {
	writeNewLine(e);
}
//writeNewLine("l_v : " + l_v);
writeNewLine("g_v : " + g_v );
```

- try-catch : 파이썬의 try-except와 같음. 에러를 잡아 처리함

- 다름 함수와 마찬가지로 전역변수, 지역변수가 있다.



### 자바스크립트의 객체 생성

1. 객체 리터럴
2. 클래스(생성자 함수)를 이용하는 방법
   - new Array(), new Date()
3. 내장 객체 : 개발자가 객체를 생성하지 않아도 자바스크립트 엔진이 자동으로 생성해주는 객체
   - window, document, navigator, screen, location, DOM객체들...



exam21~23

#### 1. 객체 리터럴

- 배열 객체 : [1, 'abc', true, 3.4]

- 객체 : {속성명 : 속성값, 속성명 : 속성값, ...}

  - 속성명 : 자바스크립트의 식별자 규칙 준수

  - 속성값 : 숫자, 문자열, 논리값, 배열, 객체, 함수(메서드)

    obj = {속성명1 : 100, 속성명2 : "둘리", 속성명 : function(){....}}

- obj.속성명1 = 100 과 같이 `.`연산자를 이용해 접근

  obj.속성명2 + "승리"

  obj.속성명3() - 메서드는 `.`연산자로만 호출할 수 있다.

- 대괄호[] 를 이용해도 접근할 수 있다.

  obj['속성명1'] = 200

  obj['속성명2'] + "승리"

  

##### 객체 생성 및 사용

```javascript
var obj = {
	name : "듀크",
	eat : function(food) {
		writeColor(this.name +"가 "+food+
                   "를 먹어요!!", "h3", "green");
	}
}
obj.eat("바나나");
writeColor(typeof obj, 'h2', "red");
obj.project = "자바스크립트";
obj.study = function() {
	writeColor(this.name +"가 "+this.project+
               "를 공부해요!!", "h3", "magenta");
}
obj.study();
for(var key in obj)
	write(key + " : " + obj[key], "h4");
write(obj.project, "h2");
write(obj["project"], "h2");
delete obj.study;
```

```javascript
var student = {
	name : "둘리",
	kor : 90,
	eng : 80,
	getSum : function() {
		return this.kor + this.eng;
	},
	toString : function() { //주석처리를 해도 에러발생x. object라는 부모객체의 tostring 메서드 수행
		return this.name +"학생의 총점은 "+this.getSum()+"입니다.";
	}
}
write("총점 : "+student.getSum(), "h3");
writeColor(student.toString(), "h3", "blue");
writeColor(student, "h3", "blue");
```

- toString() 메서드는 정의하지 않아도 수행될 수 있다.
  - 기본적으로 object 객체를 상속하기 때문에 object 객체의 tostring 메서드를 사용
- 객체명으로 호출하면 자동으로 toString() 메서드가 호출된다.



```javascript
var user1 = {}; //빈 객체 생성
user1.name = "또치";
user1.age = 11;
var user2 = {name: "둘리", age: 10}
var user3 = { father : {name : "고길동",age : 40}, son : {name : "희동이",age : 2} }
writeColor(user1.name, "h3", "blue");
writeColor(user2.name, "h3", "red");
writeColor(user3.father.name, "h3", "green");
writeColor(user3.son.name, "h3", "magenta");
```

- 객체 내부에 객체를 만들 수 있다.
  - `.` 연산자로 접근

### DOM(Document Object Model) 프로그래밍

#### DOM 객체

브라우저가 웹 페이지를 해석하고 렌더링할 때 인식된 각각의 태그들을 자바스크립트 객체로 생성하며 이 객체들을 DOM 객체라고 한다.

생성되는 DOM 객체들은 부모 자식 관계를 적용하여 트리구조로 구성한다.



####  DOM 프로그래밍에서 익혀야 하는 것

1. 동적인 처리를 하는 태그의 DOM 객체를 찾는 방법

   - document.getElementsByTagName("태그명") --> DOM객체 배열

   - document.getElementsById("id속성값") --> DOM객체

   - document.getElementsByClassName("class속성값") --> DOM객체 배열

   

   - document.querySelectorAll("CSS선택자") --> DOM객체 배열

   ```
   alert(document.querySelectorAll('h2')[0].textContent);
   ```

   - document.querySelector("CSS선택자") --> DOM객체

   ```
   var dom2 = document.querySelector('#t1');
   ```

   

   ##### document.getElementsByTagName을 이용

   ```javascript
   <h1>컨텐트1</h1>
   <h1>컨텐트2</h1>
   <h1>컨텐트3</h1>
   <h1>컨텐트4</h1>
   <h2>컨텐트5</h2>
   <script src="../util.js"></script>
   <script>
   var h1dom = document.getElementsByTagName("h1");
   write(h1dom.length, "h3");
   for(var i=0; i <h1dom.length; i++)
   	writeColor(h1dom[i].textContent, "h4", "red");
   var h2dom = document.getElementsByTagName("h2");
   writeColor(h2dom[0].textContent, "h2", "green");
   writeColor(h1dom[0], "h2", "blue");
   writeColor(h2dom[1], "h2", "blue");
   var h5dom = document.getElementsByTagName("h5");
   writeColor(h5dom.length, "h2", "magenta");
   </script>
   ```

   - `writeColor(h2dom[1], "h2", "blue");`
     - 새롭게 만들어지는 h2태그까지 인식
     - 위의 writeColor를 다른 태그로 한다면 undefined 출력 

   ```javascript
   <script>
   function myf() {
       var h1dom = document.getElementsByTagName("h1");
       for(var i=0; i <h1dom.length; i++)
   	    console.log(h1dom[i].textContent);
       console.log(h1dom[0]);
   }
   </script>
   </head>
   <body onload="myf()">
   <h1>컨텐트1</h1>
   <h1>컨텐트2</h1>
   <h1>컨텐트3</h1>
   </body>
   ```

   - `h1dom[1].textContent` : 컨텐트2
   - `h1dom[1]` : `<h1>컨텐트2</h1>`

   ##### document.getElementsById

   ```javascript
   <h1 id="t1">컨텐트1</h1>
   <h2 id="t2">컨텐트5</h2>
   <img id="t5" src="../../images/totoro.png" width="100">
   <output id="p"></output>
   <script>	// 고전이벤트모델
   window.onload = function() {
   	var dom1 = document.getElementById("t1");
   	console.log(dom1);	//<h1>컨텐트1</h1>
   	console.log(dom1.textContent);	//컨텐트1
   	var dom4 = document.getElementById("t5");
   	console.log(dom4);
   	console.log(dom4.getAttribute("src"));
   	console.log(dom4.src); 
   	var dom5 = document.getElementById("p");
   	dom5.innerHTML = "<h2>"+new Date().toLocaleString()+"</h2>";
   	//dom5.textContent = "<h2>"+new Date().toLocaleString()+"</h2>";
   }
   </script>
   ```

   - console.log(dom4.getAttribute("src")); - ../../images/totoro.png
   - console.log(dom4.src); - http://localhost:8000/edu/images/totoro.png
   - `dom5.innerHTML` : 해당 객체의 문자열을 바꿈

   

   - DOM 객체 타입 : Element타입, Attribute타입, Text타입

   ```javascript
   window.setTimeout(function() {
   	dom.innerHTML = "오늘은 불금";
   	dom.style.color ="red";
   	dom.style.backgroundColor ="lime";
   }, 5000);
   ```

   - dom 객체의 문자열을 5초 간격으로 변경



1.  찾은 DOM객체를 가지고 필요한 동적 처리를 구현하는 방법

   - 컨텐트 변경하기

     - dom.innerHTML = `"<p>새로운내용</p>"`

     - dom.textContent = "새로운내용"

     - ```javascript
       write(dom[1].textContent, "h2"); // innerText
       write(dom[1].innerHTML, "h2");
       dom.innerHTML = "오늘은 불금";
       ```

   - 스타일 바꾸기

     - dom.style.CSS속성명 = CSS속성값

     - dom.style.color = "red"

       - ```javascript
         dom.style.color ="red";
         ```

     - dom.style.backgroundColor = "yellow"

       - background-color -> backgroundColor 
       - css에서 속성명에 `-`가 들어가면 생략하고 다름 문자를 대문자로 사용

   - 이벤트 핸들러 등록하기

     - 3가지 구현방법

     1. 인라인 이벤트 모델(지역적 방식) - 태그마다 속성으로 정의

        특정 태그에 간단한 이벤트 모델을 구현할 때

        <태그명 on 이벤트명="이벤트핸들러코드">

        ```javascript
        <button onclick="startTime()">시간을 알려주라옹...</button>
        ```

     2. 고전 이벤트 모델(전역적 방식) - `<script>` 태그 안에 정의

        DOM객체를 찾는다.

        dom.on이벤트명 = function() {.......}

        ```javascript
        dom2.onclick = f2; 
        ```

        

     3. 표준 이벤트 모델(전역적 방식) - `<script>` 태그 안에 정의

        DOM객체를 찾는다.

        dom.addEventListener("이벤트명", function(){...}) 3번째 매개변수도 있지만 안써도 무관

        ```javascript
        dom3.addEventListener("click", f3); 
        ```

